package com.example.gestculture.Interfaces;

import androidx.appcompat.app.AppCompatActivity;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.os.Bundle;
import android.text.TextUtils;
import android.view.View;
import android.widget.Button;
import  android.widget.EditText;
import android.widget.Toast;
import com.example.gestculture.DAO.ParcelleDAO;
import com.example.gestculture.DAO.VisiterDAO;
import com.example.gestculture.Metier.AnneeCulturale;
import com.example.gestculture.Metier.Parcelle;
import com.example.gestculture.Metier.Visiter;
import com.example.gestculture.R;
import com.example.gestculture.SQLHelper.SQLiteHelper;

public class SaisieExploitation extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_saisie_exploitation);

        SQLiteHelper databaseHelper = new SQLiteHelper(this);
        SQLiteDatabase db = databaseHelper.getReadableDatabase();


        databaseHelper.onOpen(db);

        Button buttonBack = (Button) findViewById(R.id.btnRetourSaisie);
        Button buttonValider = (Button) findViewById(R.id.btnValideSaisie);

        EditText idExploitation = (EditText) findViewById(R.id.editTextIdExploitation);
        EditText idParcelle = (EditText) findViewById(R.id.editTextIdParcelle);
        EditText surface = (EditText) findViewById(R.id.editTextSurface);
        EditText decoupage = (EditText) findViewById(R.id.editTextDecoupage);
        EditText rend_prev = (EditText) findViewById(R.id.editTextRendPrev);
        EditText rend_real = (EditText) findViewById(R.id.editTextRendReel);
        EditText code = (EditText) findViewById(R.id.editTextCode);
        EditText matricule = (EditText) findViewById(R.id.editTextMatricule);


        buttonBack.setOnClickListener(new View.OnClickListener() {

            public void onClick(View v) {
                finish();
            }
        });

        buttonValider.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                int code_exploiStr = Integer.parseInt(idExploitation.getText().toString());
                int code_parcelleStr = Integer.parseInt(idParcelle.getText().toString());
                String surfaceStr = surface.getText().toString();
                String decoupageStr = decoupage.getText().toString();
                String rend_prevStr = rend_prev.getText().toString();
                String rend_realStr = rend_real.getText().toString();
                int codeStr = Integer.parseInt(code.getText().toString());
                String matriculeStr = matricule.getText().toString();
                AnneeCulturale anneeCulturale = new AnneeCulturale("");
                anneeCulturale.calculAnneeCulturelle();
                String annee = anneeCulturale.getAnnee();

                try {
                    if (validateFields() == true) {

                        try {
                            Parcelle parcelle = new Parcelle(annee, code_exploiStr, code_parcelleStr, surfaceStr, decoupageStr, rend_prevStr, rend_realStr, codeStr);
                            ParcelleDAO parcelleDAO = new ParcelleDAO(SaisieExploitation.this);
                            parcelleDAO.open();
                            parcelleDAO.ajouterParcelle(parcelle);
                            parcelleDAO.close();
                        } catch (Exception e) {
                            // Gérer l'exception si elle se produit
                            e.printStackTrace();
                            Toast.makeText(getApplicationContext(), "Une erreur s'est produite lors de l'insertion dans parcelle", Toast.LENGTH_SHORT).show();
                        }

                        try {
                            Visiter visiter = new Visiter(matriculeStr, code_exploiStr, annee);
                            VisiterDAO visiterDAO = new VisiterDAO(SaisieExploitation.this);
                            visiterDAO.open();
                            visiterDAO.ajouterVisite(visiter);
                            visiterDAO.close();

                        } catch (Exception e) {
                            // Gérer l'exception si elle se produit
                            e.printStackTrace();
                            Toast.makeText(getApplicationContext(), "Une erreur s'est produite lors de l'insertion dans visiter", Toast.LENGTH_SHORT).show();
                        }
                        idExploitation.setText("");
                        idParcelle.setText("");
                        surface.setText("");
                        decoupage.setText("");
                        rend_prev.setText("");
                        rend_real.setText("");
                        code.setText("");
                        matricule.setText("");
                        Toast.makeText(getApplicationContext(), "Insertion réussie !", Toast.LENGTH_SHORT).show();

                    }

                }catch (Exception e) {
                    // Gérer l'exception si elle se produit
                    e.printStackTrace();
                    Toast.makeText(getApplicationContext(), "Une erreur s'est produite", Toast.LENGTH_SHORT).show();
                }


            }


        });
    }



// Vérification des champs, si ils sont vides ou invalides on affiche un message d'erreur
    private boolean validateFields() {

        EditText idExploitation = findViewById(R.id.editTextIdExploitation);
        EditText idParcelle = findViewById(R.id.editTextIdParcelle);
        EditText surface = findViewById(R.id.editTextSurface);
        EditText decoupage = findViewById(R.id.editTextDecoupage);
        EditText rend_prev = findViewById(R.id.editTextRendPrev);
        EditText rend_real = findViewById(R.id.editTextRendReel);
        EditText code = findViewById(R.id.editTextCode);
        EditText matricule = findViewById(R.id.editTextMatricule);

        // Expression régulière pour vérifier que les champs idExploitation, idParcelle et code ne contiennent que des chiffres
        String regexNumeric = "^[0-9]+$";

        // Expression régulière pour vérifier que le matricule est au format de la plaque d'immatriculation française
        String regexMatricule = "[A-Z]{2}-\\d{3}-[A-Z]{2}";

        // Expression régulière pour vérifier que les champs surface, decoupage, rend_prev et rend_real ne contiennent pas les caractères " ou ' ou = %*`
        String regexSpecialCharacters = "^[^\"'=%*`]+$";


        try {
            if (!String.valueOf(Integer.parseInt(idExploitation.getText().toString())).matches(regexNumeric)) {
                idExploitation.setError("Champ obligatoire et doit contenir uniquement des chiffres");
                return false;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

       try {
           if (!String.valueOf(Integer.parseInt(idParcelle.getText().toString())).matches(regexNumeric)) {
               idParcelle.setError("Champ obligatoire et doit contenir uniquement des chiffres");
               return false;
           }
       }catch (Exception e) {
           e.printStackTrace();
       }

       try {
           if (!String.valueOf(Integer.parseInt(code.getText().toString())).matches(regexNumeric)) {
               code.setError("Champ obligatoire et doit contenir uniquement des chiffres");
               return false;
           }
       }catch (Exception e) {
           e.printStackTrace();
       }

        try {
            if (!matricule.getText().toString().matches(regexMatricule)) {
                matricule.setError("Champ obligatoire et doit respecter le format du matricule (ex: XX-000-XX)");
                return false;
            }
        }catch (Exception e) {
            e.printStackTrace();
        }

        try {
            if (!surface.getText().toString().matches(regexSpecialCharacters)) {
                surface.setError("Le champ ne doit pas contenir des caractères spéciaux ou être vide");
                return false;
            }
        }catch (Exception e) {
            e.printStackTrace();
        }

        try {
            if (!decoupage.getText().toString().matches(regexSpecialCharacters)) {
                decoupage.setError("Le champ ne doit pas contenir des caractères spéciaux ou être vide");
                return false;
            }
        }catch (Exception e) {
            e.printStackTrace();
        }

        try {
            if (!rend_real.getText().toString().matches(regexSpecialCharacters)) {
                rend_real.setError("Le champ ne doit pas contenir des caractères spéciaux ou être vide");
                return false;
            }
        }catch (Exception e) {
            e.printStackTrace();
        }

        try {
            if (!rend_prev.getText().toString().matches(regexSpecialCharacters)) {
                rend_prev.setError("Le champ ne doit pas contenir des caractères spéciaux ou être vide");
                return false;
            }
        }catch (Exception e) {
            e.printStackTrace();
        }

        return true;
    }
}